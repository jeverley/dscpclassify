#!/bin/sh /etc/rc.common

START=20
USE_PROCD=1

lan="$(fw4 -q zone lan)"
wan="$(fw4 -q zone wan)"

mklist() {
	echo "$*" | tr '\n' ' ' | sed -e 's/^\s*//' -e 's/\s*$//' -e 's/\s\+/, /g'
}

l4proto() {
	[ -n "$1" ] || return 0
	l4proto="meta l4proto { $(mklist "$1") }"
}

nfproto() {
	[ -n "$1" ] || return 0
	nfproto="meta nfproto { $(mklist "$1") }"
}

oifname() {
	[ -n "$1" ] || return 0
	oifname="oifname { $(mklist "$1") }"
}

iifname() {
	[ -n "$1" ] || return 0
	iifname="iifname { $(mklist "$1") }"
}

oifzone() {
	local device

	[ -n "$1" ] || return 0
	device="$(fw4 -q zone "$1")" || {
		logger -t dscpclassify "Rule contains an invalid dest zone"
		return 1
	}
	oifname "$device"
}

iifzone() {
	local device

	[ -n "$1" ] || return 0
	device="$(fw4 -q zone "$1")" || {
		logger -t dscpclassify "Rule contains an invalid src zone"
		return 1
	}
	iifname "$device"
}

check_port() {
	for i in $1; do
		echo "$i" | grep -q -E -e "^[[:digit:]]+-[[:digit:]]+$" -e "^[[:digit:]]+$" || return 1
	done
}

check_proto() {
	for i in $1; do
		case $i in
		"tcp" | "udp") true ;;
		*) return 1 ;;
		esac
	done
}

dport() {
	[ -n "$1" ] || return 0
	check_port "$1" || {
		logger -t dscpclassify "Rule contains an invalid port"
		return 1
	}
	check_proto "$2" || {
		logger -t dscpclassify "Rules cannot combine a dest_port with protocols other than 'tcp' or 'udp'"
		return 1
	}
	dport="th dport { $(mklist "$1") }"
}

sport() {
	[ -n "$1" ] || return 0
	check_port "$1" || {
		logger -t dscpclassify "Rule contains an invalid port"
		return 1
	}
	check_proto "$2" || {
		logger -t dscpclassify "Rules cannot combine a src_port with protocols other than 'tcp' or 'udp'"
		return 1
	}
	sport="th sport { $(mklist "$1") }"
}

check_ip() {
	for i in $1; do
		case $i in
		[0-9]*.[0-9]*.[0-9]*.[0-9]*) ipv4="$ipv4 $i" ;;
		*:*) ipv6="$ipv6 $i" ;;
		*) return 1 ;;
		esac
	done
}

daddr() {
	local ipv4 ipv6

	[ -n "$1" ] || return 0

	check_ip "$1" || {
		logger -t dscpclassify "Rule contains an invalid dest_ip"
		return 1
	}
	if [ -n "$ipv4" ] && [ "$2" = "ipv6" ]; then
		logger -t dscpclassify "Rules cannot combine an ipv4 dest_ip with the ipv6 family"
		return 1
	fi
	if [ -n "$ipv6" ] && [ "$2" = "ipv4" ]; then
		logger -t dscpclassify "Rules cannot combine an ipv6 dest_ip with the ipv4 family"
		return 1
	fi

	[ -n "$ipv4" ] && daddr="ip daddr { $(mklist "$ipv4") }"
	[ -n "$ipv6" ] && daddr6="ip6 daddr { $(mklist "$ipv6") }"
	return 0
}

saddr() {
	local ipv4 ipv6

	[ -n "$1" ] || return 0

	check_ip "$1" || {
		logger -t dscpclassify "Rule contains an invalid src_ip"
		return 1
	}
	if [ -n "$ipv4" ] && [ "$2" = "ipv6" ]; then
		logger -t dscpclassify "Rules cannot combine an ipv4 src_ip with the ipv6 family"
		return 1
	fi
	if [ -n "$ipv6" ] && [ "$2" = "ipv4" ]; then
		logger -t dscpclassify "Rules cannot combine an ipv6 src_ip with the ipv4 family"
		return 1
	fi

	[ -n "$ipv4" ] && saddr="ip saddr { $(mklist "$ipv4") }"
	[ -n "$ipv6" ] && saddr6="ip6 saddr { $(mklist "$ipv6") }"
	return 0
}

device() {
	[ -n "$1$2" ] || return 0
	if [ -z "$1" ] || [ -z "$2" ]; then
		logger -t dscpclassify "Rules must use the device and direction options in conjunction"
		return 1
	fi
	[ "$2" = "in" ] && {
		iifname "$1"
		return 0
	}
	[ "$2" = "out" ] && {
		oifname "$1"
		return 0
	}
	logger -t dscpclassify "The direction rule option must be either 'in' or 'out'"
	return 1

}

verdict() {
	local class

	[ -n "$1" ] || {
		logger -t dscpclassify "Rule missing a dscp class"
		return 1
	}

	class="$(echo "$1" | tr 'A-Z' 'a-z')"
	[ "$class" = "be" ] && class="cs0"

	case "$class" in
	"cs0" | "le" | "cs1" | "af11" | "af12" | "af13" | "cs2" | "af21" | "af22" | "af23" | "cs3" | "af31" | "af32" | "af33" | "cs4" | "af41" | "af42" | "af43" | "cs5" | "va" | "ef" | "cs6" | "cs7")
		verdict="goto ct_set_$class"
		return 0
		;;
	esac

	logger -t dscpclassify "Rule contains an invalid dscp class"
	return 1
}

comment() {
	[ -n "$1" ] || return 0
	comment="comment \"$*\""
}

create_user_rule() {
	local enabled family proto direction device dest dest_ip dest_port src_ip src_port class name
	local nfproto l4proto oifname daddr daddr6 dport iifname saddr saddr6 sport verdict comment

	config_get_bool enabled "$1" enabled
	[ "$enabled" = 0 ] && return 0

	config_get family "$1" family
	config_get proto "$1" proto
	config_get dest "$1" dest
	config_get dest_ip "$1" dest_ip
	config_get dest_port "$1" dest_port
	config_get src "$1" src
	config_get src_ip "$1" src_ip
	config_get src_port "$1" src_port
	config_get device "$1" device
	config_get direction "$1" direction
	config_get class "$1" class
	config_get name "$1" name

	nfproto "$family" || return 1
	l4proto "$proto" || return 1
	oifzone "$dest" || return 1
	daddr "$dest_ip" "$family" || return 1
	dport "$dest_port" "$proto" || return 1
	iifzone "$src" || return 1
	saddr "$src_ip" "$family" || return 1
	sport "$src_port" "$proto" || return 1
	device "$device" "$direction" || return 1
	verdict "$class" || return 1
	comment "$name" || return 1

	[ -z "$daddr$saddr$daddr6$saddr6" ] && {
		echo "insert rule inet dscpclassify static_classify $nfproto $l4proto $oifname $dport $iifname $sport $verdict $comment" >>"/tmp/etc/dscpclassify-post.include"
		return 0
	}
	[ -n "$daddr$saddr" ] && {
		echo "insert rule inet dscpclassify static_classify $nfproto $l4proto $oifname $daddr $dport $iifname $saddr $sport $verdict $comment" >>"/tmp/etc/dscpclassify-post.include"
	}
	[ -n "$daddr6$saddr6" ] && {
		echo "insert rule inet dscpclassify static_classify $nfproto $l4proto $oifname $daddr6 $dport $iifname $saddr6 $sport $verdict $comment" >>"/tmp/etc/dscpclassify-post.include"
	}
	return 0
}

list_append() {
	list="$list"$'\n'"$1"
}

config_foreach_reverse() {
	local list

	config_foreach list_append "$2"
	list=$(echo "$list" | sort -r)

	for config in $list; do
		"$1" "$config" "$3"
	done
}

create_pre_include() {
	local threaded_service_bytes unclassified_bytes
	rm -f "/tmp/etc/dscpclassify-pre.include"

	config_get threaded_service_bytes globals threaded_service_bytes 1000000
	config_get unclassified_bytes globals unclassified_bytes $((5 * $threaded_service_bytes))

	echo "define lan = { $(mklist "$lan") }" >>"/tmp/etc/dscpclassify-pre.include"
	echo "define wan = { $(mklist "$wan") }" >>"/tmp/etc/dscpclassify-pre.include"
	echo "define threaded_service_bytes = $threaded_service_bytes" >>"/tmp/etc/dscpclassify-pre.include"
	echo "define unclassified_bytes = $unclassified_bytes" >>"/tmp/etc/dscpclassify-pre.include"
}

create_post_include() {
	local client_hints threaded_client_kbps wmm
	rm -f "/tmp/etc/dscpclassify-post.include"

	config_get_bool client_hints globals client_hints 1
	[ "$client_hints" = 1 ] && {
		echo "insert rule inet dscpclassify static_classify iifname != \$wan ip6 dscp != { cs0, cs6, cs7 } ip6 dscp vmap @dscp_ct" >>"/tmp/etc/dscpclassify-post.include"
		echo "insert rule inet dscpclassify static_classify iifname != \$wan ip dscp != { cs0, cs6, cs7 } ip dscp vmap @dscp_ct" >>"/tmp/etc/dscpclassify-post.include"
	}

	config_foreach_reverse create_user_rule rule

	config_get threaded_client_kbps globals threaded_client_kbps 10
	echo "add rule inet dscpclassify threaded_client update @threaded_clients { meta l4proto . ip saddr . th sport timeout 5m limit rate over $threaded_client_kbps kbytes/second } ct mark set ct mark and \$ct_unused_dyn or \$cs1" >>"/tmp/etc/dscpclassify-post.include"
	echo "add rule inet dscpclassify threaded_client update @threaded_clients6 { meta l4proto . ip6 saddr . th sport timeout 5m limit rate over $threaded_client_kbps kbytes/second } ct mark set ct mark and \$ct_unused_dyn or \$cs1" >>"/tmp/etc/dscpclassify-post.include"
	echo "add rule inet dscpclassify threaded_client_response update @threaded_clients { meta l4proto . ip daddr . th dport timeout 5m limit rate over $threaded_client_kbps kbytes/second } ct mark set ct mark and \$ct_unused_dyn or \$cs1" >>"/tmp/etc/dscpclassify-post.include"
	echo "add rule inet dscpclassify threaded_client_response update @threaded_clients6 { meta l4proto . ip6 saddr . th sport timeout 5m limit rate over $threaded_client_kbps kbytes/second } ct mark set ct mark and \$ct_unused_dyn or \$cs1" >>"/tmp/etc/dscpclassify-post.include"

	config_get_bool wmm globals wmm 1
	[ "$wmm" = 1 ] && {
		echo "add rule inet dscpclassify postrouting oifname \$lan ct mark and \$ct_dscp vmap @ct_wmm" >>"/tmp/etc/dscpclassify-post.include"
	}
	echo "add rule inet dscpclassify postrouting ct mark and \$ct_dscp vmap @ct_dscp" >>"/tmp/etc/dscpclassify-post.include"
}

setup() {
	[ -n "$lan" ] || return 1
	[ -n "$wan" ] || return 1
	config_load dscpclassify || return 1
	create_pre_include
	create_post_include
	nft -f /etc/dscpclassify.d/main.nft || return 1
	rm -f "/tmp/etc/dscpclassify-pre.include"
	rm -f "/tmp/etc/dscpclassify-post.include"
}

start_service() {
	nft delete table inet dscpclassify 2>/dev/null
	setup || return 1
	logger -t dscpclassify "Service started"
}

reload_service() {
	for i in $(nft -j list chains | jsonfilter -e '@.nftables[@.chain.table="dscpclassify"].chain.name'); do
		nft flush chain inet dscpclassify "$i"
	done
	for i in $(nft -j list maps | jsonfilter -e '@.nftables[@.map.table="dscpclassify"].map.name'); do
		nft flush map inet dscpclassify "$i"
	done
	setup || return 1
	logger -t dscpclassify "Service reloaded"
}

stop_service() {
	nft delete table inet dscpclassify 2>/dev/null
	logger -t dscpclassify "Service stopped"
}
